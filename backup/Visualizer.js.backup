export class Visualizer {
    constructor(dataStore) {
        this.dataStore = dataStore;
        this.stage = null;
        this.layer = null;
        this.width = 0;
        this.height = 0;

        this.bgImageObj = new Image();
        this.bgImageNode = null;
        this.selectedNodeIds = new Set(); // Multiple selection support
        this.connectionSourceNodeId = null;
        this.nodeGroups = {}; // Store node groups for highlighting
        
        // Box selection
        this.isBoxSelecting = false;
        this.boxStartPos = null;
        this.boxSelectionRect = null;
        this.modifierKeys = { shift: false, ctrl: false };
        
        // Click debouncing (global, not per-node)
        this.lastClickTime = 0;
        this.lastClickNodeId = null;
        this.isProcessingClick = false;
        
        this.init();
    }

    init() {
        const container = document.getElementById('canvas-container');
        this.width = container.offsetWidth;
        this.height = container.offsetHeight;

        this.stage = new Konva.Stage({
            container: 'canvas-container',
            width: this.width,
            height: this.height,
        });

        this.layer = new Konva.Layer();
        this.stage.add(this.layer);

        // Handle resize
        window.addEventListener('resize', () => {
            this.width = container.offsetWidth;
            this.height = container.offsetHeight;
            this.stage.width(this.width);
            this.stage.height(this.height);
            this.render();
        });

        // Subscribe to data changes
        this.dataStore.subscribe(() => {
            this.render();
        });

        // Initial render
        this.render();

        // Keyboard event listeners for modifier keys
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') this.modifierKeys.shift = true;
            if (e.key === 'Control' || e.key === 'Meta') this.modifierKeys.ctrl = true;
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') this.modifierKeys.shift = false;
            if (e.key === 'Control' || e.key === 'Meta') this.modifierKeys.ctrl = false;
        });

        // Box selection setup
        this.setupBoxSelection();

        // Click handler for Request Mode and deselection
        this.stage.on('click', (e) => {
            const mode = this.dataStore.getState().meta.mode;
            
            // If clicked on empty space (not on a node/shape)
            // Check if target is stage or layer (background)
            if (e.target === this.stage || e.target === this.layer) {
                if (mode === 'REQUEST') {
                    // Request mode: add request marker
                    const pos = this.stage.getPointerPosition();
                    if (window.app && window.app.requestManager) {
                        window.app.requestManager.addRequest(pos.x, pos.y);
                    }
                } else {
                    // Other modes: deselect all nodes
                    // Only deselect if not using modifier keys (to allow box selection)
                    if (!this.modifierKeys.shift && !this.modifierKeys.ctrl) {
                        this.selectedNodeIds.clear();
                        this.updateAllNodeHighlights();
                        
                        // Hide property panel
                        if (window.app && window.app.propertyManager) {
                            window.app.propertyManager.deselectNode();
                        }
                    }
                }
            }
        });
    }

    setupBoxSelection() {
        let isSelecting = false;
        let startPos = null;

        this.stage.on('mousedown', (e) => {
            // Only enable box selection if clicking on stage (not on a node)
            if (e.target === this.stage && this.dataStore.getState().meta.mode === 'PHYSICAL') {
                // Don't start box selection if modifier keys are pressed (for multi-select)
                if (!this.modifierKeys.shift && !this.modifierKeys.ctrl) {
                    isSelecting = true;
                    const pos = this.stage.getPointerPosition();
                    startPos = { x: pos.x, y: pos.y };
                    this.boxStartPos = startPos;

                    // Create selection rectangle
                    this.boxSelectionRect = new Konva.Rect({
                        x: pos.x,
                        y: pos.y,
                        width: 0,
                        height: 0,
                        fill: 'rgba(59, 130, 246, 0.1)',
                        stroke: '#3b82f6',
                        strokeWidth: 2,
                        dash: [5, 5],
                        visible: false
                    });
                    this.layer.add(this.boxSelectionRect);
                    this.layer.draw();
                }
            }
        });

        this.stage.on('mousemove', (e) => {
            if (isSelecting && this.boxSelectionRect && startPos) {
                const pos = this.stage.getPointerPosition();
                const width = pos.x - startPos.x;
                const height = pos.y - startPos.y;

                this.boxSelectionRect.setAttrs({
                    x: width < 0 ? pos.x : startPos.x,
                    y: height < 0 ? pos.y : startPos.y,
                    width: Math.abs(width),
                    height: Math.abs(height),
                    visible: true
                });
                this.layer.draw();
            }
        });

        this.stage.on('mouseup', (e) => {
            if (isSelecting && this.boxSelectionRect && startPos) {
                const pos = this.stage.getPointerPosition();
                const box = {
                    x: Math.min(startPos.x, pos.x),
                    y: Math.min(startPos.y, pos.y),
                    width: Math.abs(pos.x - startPos.x),
                    height: Math.abs(pos.y - startPos.y)
                };

                // Select nodes within box
                this.selectNodesInBox(box);

                // Remove selection rectangle
                this.boxSelectionRect.destroy();
                this.boxSelectionRect = null;
                this.boxStartPos = null;
                this.layer.draw();

                isSelecting = false;
                startPos = null;
            }
        });
    }

    selectNodesInBox(box) {
        const selectedNodes = new Set();
        
        Object.values(this.nodeGroups).forEach(group => {
            const nodeBox = {
                x: group.x(),
                y: group.y(),
                width: 100,
                height: 60
            };

            // Check if node intersects with selection box
            if (this.boxIntersects(box, nodeBox)) {
                selectedNodes.add(group.id());
            }
        });

        // Update selection
        if (!this.modifierKeys.shift && !this.modifierKeys.ctrl) {
            this.selectedNodeIds.clear();
        }
        selectedNodes.forEach(id => {
            this.selectedNodeIds.add(id);
        });

        this.updateAllNodeHighlights();
    }

    boxIntersects(box1, box2) {
        return !(box1.x + box1.width < box2.x ||
                 box2.x + box2.width < box1.x ||
                 box1.y + box1.height < box2.y ||
                 box2.y + box2.height < box1.y);
    }

    render() {
        const data = this.dataStore.getState();
        const mode = data.meta.mode;

        // Clean up invalid selections (nodes that no longer exist)
        const existingNodeIds = new Set(Object.keys(data.nodes));
        const validSelections = new Set();
        this.selectedNodeIds.forEach(nodeId => {
            if (existingNodeIds.has(nodeId)) {
                validSelections.add(nodeId);
            }
        });
        this.selectedNodeIds = validSelections;

        // Clear node groups cache when re-rendering
        this.nodeGroups = {};
        this.layer.destroyChildren();

        // Render Background Image
        if (data.meta.floorPlanImage && (mode === 'PHYSICAL' || mode === 'REQUEST')) {
            if (!this.bgImageNode) {
                this.bgImageNode = new Konva.Image({
                    x: 0, y: 0,
                    image: this.bgImageObj,
                });
            }

            // Update image source if changed
            if (this.bgImageObj.src !== data.meta.floorPlanImage) {
                this.bgImageObj.src = data.meta.floorPlanImage;
                this.bgImageObj.onload = () => {
                    this.layer.batchDraw();
                };
            }

            this.layer.add(this.bgImageNode);
        }

        // Render Connections (TODO)

        // Render Nodes
        Object.values(data.nodes).forEach(node => {
            this.renderNode(node, mode);
        });

        // Render Requests
        Object.values(data.requests).forEach(req => {
            this.renderRequest(req);
        });

        this.layer.batchDraw();
    }

    renderRequest(req) {
        const size = 30;
        const group = new Konva.Group({
            x: req.x,
            y: req.y,
            draggable: false // Requests are static for now, or editable in future
        });

        const rect = new Konva.Rect({
            width: size, height: size,
            fill: req.type === 'POWER' ? '#fca5a5' : '#93c5fd', // red-300 : blue-300
            stroke: req.type === 'POWER' ? '#ef4444' : '#3b82f6', // red-500 : blue-500
            strokeWidth: 2,
            offset: { x: size / 2, y: size / 2 }
        });

        const text = new Konva.Text({
            text: req.label,
            fontSize: 14,
            fontStyle: 'bold',
            fill: 'white',
            offset: { x: 4, y: 6 } // Approximate center
        });

        group.add(rect);
        group.add(text);
        this.layer.add(group);
    }

    renderNode(node, mode) {
        let x, y;
        let draggable = false;

        if (mode === 'LOGICAL') {
            // Grid mapping for logical (using 24px grid)
            x = (node.logicalPos?.col || 0) * 24;
            y = (node.logicalPos?.row || 0) * 24;
            draggable = true; // Enable dragging in LOGICAL mode
        } else {
            // Physical / Request
            x = node.physicalPos?.x || 0;
            y = node.physicalPos?.y || 0;
            draggable = (mode === 'PHYSICAL');
        }

        const group = new Konva.Group({
            x: x,
            y: y,
            draggable: draggable,
            id: node.id
        });

        // Dynamic Color
        const nodeColor = node.color || '#94a3b8'; // Default slate-400

        // Shape (Rounded Rect)
        const rect = new Konva.Rect({
            width: 100,
            height: 60,
            fill: 'white',
            stroke: nodeColor,
            strokeWidth: 2,
            cornerRadius: 8,
            shadowColor: 'black',
            shadowBlur: 5,
            shadowOpacity: 0.1,
            shadowOffset: { x: 2, y: 2 }
        });

        // Header Background (Colored)
        const header = new Konva.Rect({
            width: 100,
            height: 20,
            fill: nodeColor,
            cornerRadius: [8, 8, 0, 0]
        });

        // Type Label - centered if no model, otherwise positioned above
        const hasModel = node.model && node.model.trim() !== '';
        const typeText = new Konva.Text({
            text: node.type || node.id.replace(/-\d+$/, ''), // Remove trailing numbers from id if type not available
            fontSize: 12,
            fontStyle: 'bold',
            y: hasModel ? 25 : 40, // Above model if exists, centered at box center (40px) if not
            width: 100,
            align: 'center',
            fill: '#334155',
            offsetY: hasModel ? 0 : 6 // Adjust to center text vertically when no model (half of font size)
        });

        group.add(rect);
        group.add(header);
        group.add(typeText);

        // Model Label - only show if model exists
        if (hasModel) {
            const modelText = new Konva.Text({
                text: node.model,
                fontSize: 10,
                y: 40,
                width: 100,
                align: 'center',
                fill: '#94a3b8'
            });
            group.add(modelText);
        }

        // Store group reference for highlighting
        this.nodeGroups[node.id] = group;

        // Selection Handler - use only 'click' to avoid duplicate events
        group.on('click', (e) => {
            e.cancelBubble = true;
            
            // Prevent concurrent click processing
            if (this.isProcessingClick) {
                return;
            }
            
            const now = Date.now();
            const timeSinceLastClick = now - this.lastClickTime;
            const isSameNode = this.lastClickNodeId === node.id;
            
            // Prevent rapid duplicate clicks on same node (within 100ms)
            if (isSameNode && timeSinceLastClick < 100) {
                return;
            }
            
            this.isProcessingClick = true;
            this.lastClickTime = now;
            this.lastClickNodeId = node.id;
            
            // Handle node selection
            if (this.onNodeSelect) {
                const isMultiSelect = this.modifierKeys.shift || this.modifierKeys.ctrl;
                
                if (isMultiSelect) {
                    // Multi-select mode: toggle selection
                    if (this.selectedNodeIds.has(node.id)) {
                        this.selectedNodeIds.delete(node.id);
                    } else {
                        this.selectedNodeIds.add(node.id);
                    }
                } else {
                    // Single select mode: ALWAYS clear all selections first, then select this node
                    // If clicking the same single-selected node, deselect it
                    const wasSelected = this.selectedNodeIds.has(node.id);
                    const wasOnlySelected = this.selectedNodeIds.size === 1 && wasSelected;
                    
                    // Always clear first
                    this.selectedNodeIds.clear();
                    
                    if (!wasOnlySelected) {
                        // Select this node (unless it was the only selected one)
                        this.selectedNodeIds.add(node.id);
                    }
                }
                
                // Update highlights immediately
                this.updateAllNodeHighlights();
                
                // Call original handler for property panel (only if node is selected)
                if (this.selectedNodeIds.has(node.id) && this.selectedNodeIds.size === 1) {
                    this.onNodeSelect(node.id);
                } else if (this.selectedNodeIds.size === 0) {
                    // Deselect property panel if nothing is selected
                    if (window.app && window.app.propertyManager) {
                        window.app.propertyManager.deselectNode();
                    }
                }
            }
            
            // Reset processing flag after a short delay
            setTimeout(() => {
                this.isProcessingClick = false;
            }, 50);
        });

        // Drag events - handle both single and multi-node drag
        if (mode === 'PHYSICAL' || mode === 'LOGICAL') {
            group.on('dragstart', () => {
                // Store initial positions for multi-node drag
                if (this.selectedNodeIds.has(node.id) && this.selectedNodeIds.size > 1) {
                    this.selectedNodeIds.forEach(selectedId => {
                        if (this.nodeGroups[selectedId]) {
                            const selectedGroup = this.nodeGroups[selectedId];
                            selectedGroup.setAttr('_startX', selectedGroup.x());
                            selectedGroup.setAttr('_startY', selectedGroup.y());
                        }
                    });
                }
            });

            group.on('dragmove', () => {
                // Don't snap during drag - allow free movement
                // Snap will be applied on dragend

                // Move all selected nodes together if multi-selected
                if (this.selectedNodeIds.has(node.id) && this.selectedNodeIds.size > 1) {
                    const currentX = group.x();
                    const currentY = group.y();
                    const startX = group.getAttr('_startX') || currentX;
                    const startY = group.getAttr('_startY') || currentY;
                    const deltaX = currentX - startX;
                    const deltaY = currentY - startY;
                    
                    this.selectedNodeIds.forEach(selectedId => {
                        if (selectedId !== node.id && this.nodeGroups[selectedId]) {
                            const selectedGroup = this.nodeGroups[selectedId];
                            const nodeStartX = selectedGroup.getAttr('_startX') || selectedGroup.x();
                            const nodeStartY = selectedGroup.getAttr('_startY') || selectedGroup.y();
                            const newX = nodeStartX + deltaX;
                            const newY = nodeStartY + deltaY;
                            
                            // Don't snap during drag - allow free movement
                            selectedGroup.position({ x: newX, y: newY });
                        }
                    });
                    this.layer.batchDraw();
                }
            });

            group.on('dragend', (e) => {
                // Update positions of all selected nodes
                if (this.selectedNodeIds.has(node.id) && this.selectedNodeIds.size > 1) {
                    // Multi-node drag
                    this.selectedNodeIds.forEach(selectedId => {
                        if (this.nodeGroups[selectedId]) {
                            const selectedGroup = this.nodeGroups[selectedId];
                            const nodeData = this.dataStore.getState().nodes[selectedId];
                            if (nodeData) {
                                if (mode === 'LOGICAL') {
                                    // Snap to nearest grid position
                                    const currentX = selectedGroup.x();
                                    const currentY = selectedGroup.y();
                                    const snappedX = this.snapToGridX(currentX);
                                    const snappedY = this.snapToGridY(currentY);
                                    // Apply snap position
                                    selectedGroup.position({ x: snappedX, y: snappedY });
                                    // Convert pixel position to grid coordinates (using 24px grid)
                                    const col = Math.round(snappedX / 24);
                                    const row = Math.round(snappedY / 24);
                                    this.dataStore.updateNode(selectedId, {
                                        logicalPos: { col, row }
                                    });
                                } else {
                                    this.dataStore.updateNode(selectedId, {
                                        physicalPos: {
                                            x: selectedGroup.x(),
                                            y: selectedGroup.y()
                                        }
                                    });
                                }
                            }
                        }
                    });
                    // Redraw layer after snapping all nodes
                    if (mode === 'LOGICAL') {
                        this.layer.batchDraw();
                    }
                } else {
                    // Single node drag
                    if (mode === 'LOGICAL') {
                        // Get current position and snap to nearest grid
                        const currentX = group.x();
                        const currentY = group.y();
                        const snappedX = this.snapToGridX(currentX);
                        const snappedY = this.snapToGridY(currentY);
                        // Apply snap position
                        group.position({ x: snappedX, y: snappedY });
                        // Convert pixel position to grid coordinates (using 24px grid)
                        const col = Math.round(snappedX / 24);
                        const row = Math.round(snappedY / 24);
                        this.dataStore.updateNode(node.id, {
                            logicalPos: { col, row }
                        });
                        // Redraw layer after snapping
                        this.layer.batchDraw();
                    } else {
                        this.dataStore.updateNode(node.id, {
                            physicalPos: {
                                x: group.x(),
                                y: group.y()
                            }
                        });
                    }
                }
            });
        }

        // Update selection highlight if this node is selected
        this.updateNodeHighlight(node.id);

        this.layer.add(group);
    }

    highlightNode(nodeId, type = 'selected') {
        if (type === 'source') {
            this.connectionSourceNodeId = nodeId;
        } else {
            this.selectedNodeIds.clear();
            this.selectedNodeIds.add(nodeId);
        }
        this.updateAllNodeHighlights();
    }

    clearNodeSelection() {
        const previousSource = this.connectionSourceNodeId;
        this.selectedNodeIds.clear();
        this.connectionSourceNodeId = null;
        
        if (previousSource && this.nodeGroups[previousSource]) {
            this.updateNodeHighlight(previousSource);
        }
        this.updateAllNodeHighlights();
    }

    snapToGridX(x) {
        // Grid spacing: 24px (matches canvas dot grid)
        return Math.round(x / 24) * 24;
    }

    snapToGridY(y) {
        // Grid spacing: 24px (matches canvas dot grid)
        return Math.round(y / 24) * 24;
    }

    updateAllNodeHighlights() {
        Object.keys(this.nodeGroups).forEach(nodeId => {
            this.updateNodeHighlight(nodeId);
        });
        
        // Update draggable state based on mode only (not selection)
        const mode = this.dataStore.getState().meta.mode;
        const isDraggable = mode === 'PHYSICAL' || mode === 'LOGICAL';
        
        Object.keys(this.nodeGroups).forEach(nodeId => {
            const group = this.nodeGroups[nodeId];
            if (group) {
                // Enable dragging in PHYSICAL and LOGICAL modes for all nodes
                group.draggable(isDraggable);
            }
        });
    }

    updateNodeHighlight(nodeId) {
        const group = this.nodeGroups[nodeId];
        if (!group) return;

        // Remove existing highlight rectangles
        const existingHighlight = group.findOne('.selection-highlight');
        const existingSourceHighlight = group.findOne('.source-highlight');
        if (existingHighlight) existingHighlight.destroy();
        if (existingSourceHighlight) existingSourceHighlight.destroy();

        // Add highlight if node is selected or is connection source
        const isSelected = this.selectedNodeIds.has(nodeId);
        const isSource = this.connectionSourceNodeId === nodeId;

        if (isSelected || isSource) {
            const highlightColor = isSource ? '#3b82f6' : '#10b981'; // Blue for source, green for selected
            const highlight = new Konva.Rect({
                name: isSource ? 'source-highlight' : 'selection-highlight',
                width: 100,
                height: 60,
                fill: 'transparent',
                stroke: highlightColor,
                strokeWidth: 3,
                cornerRadius: 8,
                dash: isSource ? [5, 5] : []
            });
            group.add(highlight);
            group.moveChild(highlight, 0); // Move to front
        }

        this.layer.batchDraw();
    }
}
